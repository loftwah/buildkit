name: Mirror All Docker Images to GHCR

on:
  workflow_dispatch:  # Manual only, no fucking schedules

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
      id-token: write  # For better security with OIDC
    
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install jq for Tag Parsing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Check Docker Hub Rate Limits
        run: |
          TOKEN=$(curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:ratelimitcheck/test:pull" | jq -r .token)
          LIMITS=$(curl -s -H "Authorization: Bearer $TOKEN" https://registry-1.docker.io/v2/ratelimitcheck/test/manifests/latest 2>&1 | grep -i 'ratelimit')
          echo "Current Docker Hub rate limits: $LIMITS"
          if [[ $LIMITS == *"429 Too Many Requests"* ]]; then
            echo "Rate limit exceeded, waiting..."
            exit 1
          fi
        continue-on-error: true

      - name: Fetch and Mirror All Image Versions
        env:
          GHCR_PREFIX: ghcr.io/${{ github.repository }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Function to get latest + 2 prior stable tags from Docker Hub
          get_tags() {
            IMAGE=$1
            REPO=$2
            echo "Attempting to get token for $REPO/$IMAGE..."
            
            # Get token for Docker Hub API with credentials
            TOKEN=$(curl -s -u "${DOCKERHUB_USERNAME}:${DOCKERHUB_TOKEN}" \
              "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${REPO}/${IMAGE}:pull" | jq -r .token)
            
            if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
              echo "Failed to get token for $REPO/$IMAGE"
              return 1
            fi
            
            echo "Got token, fetching tags..."
            
            # Get tags and filter for semantic versions
            TAGS=$(curl -s -H "Authorization: Bearer $TOKEN" \
              "https://registry.hub.docker.com/v2/${REPO}/${IMAGE}/tags/list")
            
            if [ -z "$TAGS" ]; then
              echo "No response from Docker Hub API"
              return 1
            fi
            
            echo "Raw tags response: $TAGS"
            
            echo "$TAGS" | \
              jq -r '.tags[]?' 2>/dev/null | \
              grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | \
              sed 's/^v//' | \
              sort -t. -k1,1nr -k2,2nr -k3,3nr | \
              head -n 3
          }

          # Process each image
          for image in "buildkit:moby/buildkit" "ruby:library/ruby" "nginx:library/nginx" "node:library/node"; do
            IFS=':' read -r NAME REPO <<< "$image"
            echo "Processing: NAME=$NAME REPO=$REPO"
            
            # Add retry mechanism with better error handling
            for i in {1..3}; do
              echo "Attempt $i to fetch tags..."
              TAGS=$(get_tags "$NAME" "$REPO")
              RESULT=$?
              echo "get_tags exit code: $RESULT"
              echo "Retrieved tags: $TAGS"
              
              if [ $RESULT -eq 0 ] && [ ! -z "$TAGS" ]; then
                echo "Successfully fetched tags"
                break
              fi
              echo "Attempt $i failed, waiting before retry..."
              sleep 5
            done

            if [ -z "$TAGS" ]; then
              echo "No valid tags found for $NAME after 3 attempts, skipping."
              continue
            fi

            echo "Found tags: $TAGS"
            for TAG in $TAGS; do
              SOURCE="$REPO/$NAME:$TAG"
              TARGET="$GHCR_PREFIX/$NAME:$TAG"
              echo "Mirroring $SOURCE -> $TARGET"
              if docker pull "$SOURCE"; then
                docker tag "$SOURCE" "$TARGET"
                if ! docker push "$TARGET"; then
                  echo "Push failed for $TARGET, skipping"
                  continue
                fi
              else
                echo "Pull failed for $SOURCE, skipping"
                continue
              fi
            done

            # Handle latest tag separately
            LATEST_SOURCE="$REPO/$NAME:latest"
            LATEST_TARGET="$GHCR_PREFIX/$NAME:latest"
            echo "Mirroring latest: $LATEST_SOURCE -> $LATEST_TARGET"
            if docker pull "$LATEST_SOURCE"; then
              docker tag "$LATEST_SOURCE" "$LATEST_TARGET"
              if ! docker push "$LATEST_TARGET"; then
                echo "Push failed for $LATEST_TARGET"
              fi
            else
              echo "Pull failed for $LATEST_SOURCE"
            fi
          done
        shell: bash

      - name: Notify on Success
        if: success() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"âœ… Successfully mirrored all images for ${{ github.repository }}! Check logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
            "$SLACK_WEBHOOK_URL"
        continue-on-error: true

      - name: Notify on Failure
        if: failure() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"ðŸš¨ All image mirroring failed for ${{ github.repository }}! Check logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
            "$SLACK_WEBHOOK_URL"
        continue-on-error: true